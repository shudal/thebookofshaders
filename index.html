
<body>
    <div id="container"></div>
    <script src="js/three.min.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">

#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359
#define TWO_PI 6.28318530718

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

vec3 rgb2hsb( in vec3 c ){
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz),
                 vec4(c.gb, K.xy),
                 step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r),
                 vec4(c.r, p.yzx),
                 step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),
                d / (q.x + e),
                q.x);
}

//  Function from IÃ±igo Quiles
//  https://www.shadertoy.com/view/MsS3Wc
vec3 hsb2rgb( in vec3 c ){
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                             6.0)-3.0)-1.0,
                     0.0,
                     1.0 );
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * mix(vec3(1.0), rgb, c.y);
}
float min3 (vec3 v) {
  	return min (min (v.x, v.y), v.z);
}

float max3 (vec3 v) {
  	return max (max (v.x, v.y), v.z);
}
// ref: http://nishitalab.org/user/UEI/publication/Sugita_IWAIT2015.pdf
vec3 RGBtoRYB(vec3 RGB)
{
    vec3 rgb = RGB;
    
    // Remove white component
    float Iw = min3(RGB);
    rgb -= Iw;
    
    vec3 RYB;
    
    // Derive RYB
    float rg = min(rgb.r, rgb.g);
    RYB.r = rgb.r - rg;
    RYB.y = 0.5 * (rgb.g + rg);
    RYB.b = 0.5 * (rgb.b + rgb.g - rg);
    
    // Normalize
    float n = max3(RYB) / max3(rgb);
    if (n > 0.0)
    	RYB /= n;
    
    // Add black 
    float Ib = min3(vec3(1.0) - RGB);
    RYB += Ib;
    
    return RYB;
}
#define TWO_PI 6.28318530718
 
vec3 drawRect(vec2 st,vec2 plb, vec2 prt) {
	
    vec2 bl = floor(st-plb)+1.0;
	float pct = bl.x * bl.y;

    // top-right 
    vec2 tr = floor(1.0-st-prt)+1.0;
	pct *= tr.x * tr.y;

	//pct = 1.0-pct;
    vec3 color = vec3(pct); 
    return color;
    //fcolor += color;
	//gl_FragColor += vec4(color,1.);
}
bool IsInnerRect(vec2 st,vec2 plb, vec2 prt) {
	bool ans,b1,b2;
	if (st.x > plb.x && st.y > plb.y) {
		b1 = true;
	} 
	prt = 1.0 - prt;
	if (st.x < prt.x && st.y < prt.y) {
		b2 = true;
	}
	ans = b1 && b2;
	return ans; 
}
void drawRectOnlyOutline(vec2 st,vec2 plb, vec2 prt,vec2 outlineAdd) { 
	float pct=0.; 
	if (IsInnerRect(st,plb,prt) && (!IsInnerRect(st,plb+outlineAdd,prt+outlineAdd))) {
		pct = 1.;
	} 
    vec3 color = vec3(pct);  
	gl_FragColor += vec4(color,1.);
}
float f1(float x) {
	return abs(sin(x+u_time*1.0));
}
vec2 f1(vec2 x) {
	return vec2(f1(x.x),f1(x.y));
}

float plot(vec2 st, float pct){
    return  smoothstep( pct-0.02, pct, st.y) -
            smoothstep( pct, pct+0.02, st.y);
  }
void drawCycle(vec2 st, vec2 ori, float r, float outHalfWid) {
	float dis=distance(st,ori);
      
	if (dis < (r+outHalfWid) && dis > (r-outHalfWid)) { 
		//gl_FragColor = vec4(hsb2rgb(vec3(f1(dis),f1(1.),f1(1.))),1.);
		vec2 n = normalize(st-ori);
		vec2 x1 = abs(smoothstep(ori+(r - outHalfWid)*n ,ori+(r +outHalfWid)*n,st) - 0.5)*2.0;
		x1 = 1.0 - x1;
		vec3 color;
		color = vec3(x1.x*x1.y);
		//vec3 color = hsb2rgb(vec3(f1(x1.x*x1.y),f1(1.),f1(1.)));
		gl_FragColor += vec4(color,1.);
		
	} 
}

void drawCycleTmp(vec2 st) {
	float pct;
	pct = distance(st,vec2(0.4)) + distance(st,vec2(0.6));
	pct = distance(st,vec2(0.4)) + distance(st,vec2(0.6));

	//pct = distance(st,vec2(0.4)) * distance(st,vec2(0.6));
	//pct = distance(st,f1(vec2(0.4,0.6))) * distance(st,vec2(0.6));
	
    //pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));
	//pct = min(distance(f1(st),f1(vec2(0.4,0.2))),distance(st,vec2(0.6)));
	
    //pct = max(distance(st,vec2(0.4)),distance(st,vec2(0.6)));
	//pct = max(distance(f1(st),vec2(f1(0.4))),distance(st,f1(vec2(0.6))));
	//pct = pow(distance(f1(st),vec2(f1(0.4),f1(0.3))),distance(f1(st),f1(vec2(0.6))));
	
	vec3 color = vec3(0.); 
    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);
	gl_FragColor = vec4(color,1.0);
}
void drawFlower(vec2 st, vec2 ori, float cntHuaBan, float wid,float huaBanLenAdd) {
    vec3 color = vec3(0.0);

    vec2 pos = ori-st;

    float r = length(pos)*2.0;
    float a = atan(pos.y,pos.x);
    //a = f1(a);

    float f = abs(cos(a*(cntHuaBan / 2.0))) * wid + huaBanLenAdd; 
    f = abs(fract(a*cntHuaBan)*wid)+huaBanLenAdd;
    //f = f1(f);
    float sv = smoothstep(f,f+0.05,r);
    if (sv > 0. && sv < 1.) { 
        color = vec3(sv);
        gl_FragColor += vec4(color, 1.0);
    }
}
void drawMultiShaped(vec2 st, vec2 ori, int N, float outr, float outWid) {
  st=st+(vec2(0.5,0.5)-ori);

  vec3 color = vec3(0.0);
  float d = 0.0;

  // Remap the space to -1. to 1.
  st = st *2.-1.;
 

  // Angle and radius from the current pixel
  float a = atan(st.x,st.y)+PI;
  float r = TWO_PI/float(N);

  // Shaping function that modulate the distance
  d = cos(floor(.5+a/r)*r-a)*length(st);

  color = vec3(1.-smoothstep(outr, outr+outWid,d));
  
  gl_FragColor += vec4(color,1.0);
}

float box(in vec2 _st, in vec2 _size){
    _size = vec2(0.5) - _size*0.5;
    vec2 uv = smoothstep(_size,
                        _size+vec2(0.001),
                        _st);
    uv *= smoothstep(_size,_size+vec2(0.001), vec2(1.0)-_st);
    return uv.x*uv.y;
}

float cross(in vec2 _st, float _size){
	float x1=box(_st, vec2(_size,_size/4.));
    float x2=box(_st, vec2(_size/4.,_size));
	float ans=x1+x2;
	return ans;
}
mat2 rotate2d(float _angle){
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
}
mat2 scale(vec2 _scale){
    return mat2(_scale.x,0.0,
                0.0,_scale.y);
}
vec2 toGrid(vec2 st, vec2 s,out int row, out int col) {
	st = st *s;
	
	row = int(floor(st.y));
	col = int(floor(st.x));
	st = fract(st);
	return st;
}
void main(){
    vec2 st = gl_FragCoord.xy/u_resolution.xy;
    
	int row,col;
	st = toGrid(st,vec2(6,6),row,col); 
	
    vec3 color=vec3(0.);
 
 
	if (mod(float(row),2.) == 0.) { 

	} else {   
        st.x += 0.4;
        //st = fract(st);
	}

    color = vec3(box(st,vec2(0.9)));
    bool x=IsInnerRect(st,vec2(0.05),vec2(0.05));
    if (x) {
        //color = vec3(1.);
        //color = hsb2rgb(    vec3(   st.x*st.y,   1., 1.)   );
    } 
	gl_FragColor = vec4(color,1.0);

}



    </script>
    <script>
        var container;
        var camera, scene, renderer, clock;
        var uniforms;

        init();
        animate();

        function init() {
            container = document.getElementById( 'container' );

            camera = new THREE.Camera();
            camera.position.z = 1;
			//camera.position.x=2.1;

            scene = new THREE.Scene();
            clock = new THREE.Clock();

            var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

            uniforms = {
                u_time: { type: "f", value: 1.0 },
                u_resolution: { type: "v2", value: new THREE.Vector2() }
            };

            var material = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent
            } );

            var mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );

            container.appendChild( renderer.domElement );

            onWindowResize();
            window.addEventListener( 'resize', onWindowResize, false );
        }

        function onWindowResize( event ) {
			var f1=1.0;
			var w=500;
			var h=500;
            //renderer.setSize( window.innerWidth *f1, window.innerHeight * f1 );
            renderer.setSize( w, h );
            uniforms.u_resolution.value.x = renderer.domElement.width * f1;
            uniforms.u_resolution.value.y = renderer.domElement.height * f1;
            //uniforms.u_resolution.value.x = w;
            //uniforms.u_resolution.value.y = h;
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            uniforms.u_time.value += clock.getDelta();
            renderer.render( scene, camera );
        }
    </script>
	<style type="text/css">
	 #container { 
	 }
	</style>
</body>